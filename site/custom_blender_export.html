<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Morten H. Solvang" />
  <title>A custom binary exporter in blender</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      div.line-block{white-space: pre-line;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
div.sourceLine, a.sourceLine { display: inline-block; min-height: 1.25em; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; }
@media print {
code.sourceCode { white-space: pre-wrap; }
div.sourceLine, a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource div.sourceLine, .numberSource a.sourceLine
  { position: relative; }
pre.numberSource div.sourceLine::before, .numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em; }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
pre, code { color: #cccccc; background-color: #303030; }
@media screen {
a.sourceLine::before { text-decoration: underline; color: initial; }
}
code span.kw { color: #f0dfaf; } /* Keyword */
code span.dt { color: #dfdfbf; } /* DataType */
code span.dv { color: #dcdccc; } /* DecVal */
code span.bn { color: #dca3a3; } /* BaseN */
code span.fl { color: #c0bed1; } /* Float */
code span.ch { color: #dca3a3; } /* Char */
code span.st { color: #cc9393; } /* String */
code span.co { color: #7f9f7f; } /* Comment */
code span.ot { color: #efef8f; } /* Other */
code span.al { color: #ffcfaf; } /* Alert */
code span.fu { color: #efef8f; } /* Function */
code span.er { color: #c3bf9f; } /* Error */
code span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */
code span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
code span.sc { color: #dca3a3; } /* SpecialChar */
code span.vs { color: #cc9393; } /* VerbatimString */
code span.ss { color: #cc9393; } /* SpecialString */
code span.im { } /* Import */
code span.va { } /* Variable */
code span.cf { color: #f0dfaf; } /* ControlFlow */
code span.op { color: #f0efd0; } /* Operator */
code span.bu { } /* BuiltIn */
code span.ex { } /* Extension */
code span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
code span.at { } /* Attribute */
code span.do { color: #7f9f7f; } /* Documentation */
code span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
code span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
code span.in { color: #7f9f7f; font-weight: bold; } /* Information */
  </style>
  <link rel="stylesheet" href="style.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div id="back-button">
    <a href="index.html">Home</a>
</div>
<header>
<h1 class="title">A custom binary exporter in blender</h1>
<p class="author">Morten H. Solvang</p>
<p class="date">November, 2017</p>
</header>
<p>I use blender’s built in python scripting capabilities to export models in a custom binary format. This gives me greater control over the model pipeline in my game, in turn allowing me to do some handy things. For example, I can <em>“draw”</em> hitboxes in blender and load them directly in my game, without going through external formats or tools.</p>
<p>In this post I will talk a bit about how to write such an exporter exporter, and which benefits I see in using it over using blender’s default exporters. Note that there won’t be a complete code sample, as you probably want to write a custom format yourself if you are doing this.</p>
<figure>
<img src="figures/custom_blender_export_figure_1.png" alt="Figure 1: The process, exemplified by beautifull programmer art" /><figcaption>Figure 1: The process, exemplified by beautifull programmer art</figcaption>
</figure>
<p>For reference, this was done in blender version <em>2.75</em>. Things might be different in other versions!</p>
<h2 id="why">Why?</h2>
<p>Writing the exporter and corresponding importer definetly was a bit of work, but I still think that it was a worthwhile project. For one, I really enjoyed working on it, and usually that in itself is enough justification for a hobby project. There are however also some tangible benefits over the standard ways of exporting in blender:</p>
<p>For one, I can retrieve exactly the data I am interested in. With other model formats, you have to sift through the information stored in the format to get the values you want in your game. With a custom exporter, you can move this sifting to the exporter as you have full control over the entire pipeline. Additionally, I know for certain that I can parse every valid model file my generator outputs.</p>
<p>As shown in figure 1, I can bundle additional data in my model exports. I am sure you could somehow hoax formats like <code>.fbx</code> or <code>.dae</code> into doing something like this, but the complexity of these formats have never alowed me to use them efficiently or enjoyably. Being able to place hitboxes directly inside blender gives a nice usability and productivity benefit, as I don’t have to fiddle around with some other custom solution.</p>
<h2 id="the-basics-of-scripting-in-python">The basics of scripting in python</h2>
<p>In case you have never scripted in blender, I will give a brief introduction to this. Feel free to skip ahead if you already know this.</p>
<p>First, you need to set yourself up for python scripting in blender. There are two “tools” to use: The built-in console and the text editor. Figure 2 shows a sample setup.</p>
<figure>
<img src="figures/custom_blender_export_figure_2.png" alt="Figure 2: The basic setup for scripting in blender" /><figcaption>Figure 2: The basic setup for scripting in blender</figcaption>
</figure>
<p>Legend for figure 2:</p>
<ol type="1">
<li><p>Output in the system console. <code>print()</code> prints to the system console rather than the integrated console. You can toggle this console via <code>Window &gt; Toggle System Console</code></p></li>
<li><p>You switch to the built in text editor using this dropdown. You can also write in an external editor, which is a lot nicer. See <a href="https://blender.stackexchange.com/a/56709">here</a> for instructions on how to run an external file (Not sure if the solution there is <em>good</em> though).</p></li>
<li><p>Press this button to run your script. For me, the button exports all the models in the scene.</p></li>
<li><p>The interactive console can be found in the same dropdown menu as the text editor. It has autocomplete (<code>Ctrl + Space</code>), which coupled with some guesswork gets you a long way in figuring out the fields available on objects.</p></li>
<li><p>You can have multiple files open in blender’s text editor, and this menu switches between them. At first, it will say <code>+ New</code>. If you press it once, it creates a new “file”. You have to do this before you can start writing code.</p></li>
</ol>
<p>Lastly, you should <code>import bpy</code> to access blender’s python api.</p>
<h2 id="getting-data-from-blender">Getting data from blender</h2>
<p>In order to export data to a custom format, you first have to retrieve it from blender. I’ll go over some of the main data sources here. For more detailed info, you can refer to <a href="https://docs.blender.org/api/current/">blender’s api</a>.</p>
<p>All objects in the scene can be iterated over with <code>for object in bpy.context.scene.objects</code>. You probably only want to export meshes, which you can check for with <code>object.type == 'MESH'</code>.</p>
<p>When exporting mesh data, you probably want to triangulate the mesh first, so you don’t have to do this in-game before rendering. For objects which are meshes, this can be done as follows:</p>
<pre class="sourceCode python" id="cb1"><code class="sourceCode python"><div class="sourceLine" id="cb1-1" data-line-number="1"><span class="im">import</span> bmesh</div>
<div class="sourceLine" id="cb1-2" data-line-number="2"></div>
<div class="sourceLine" id="cb1-3" data-line-number="3"><span class="co"># Create a mesh you can manipulate from the object data</span></div>
<div class="sourceLine" id="cb1-4" data-line-number="4">mesh <span class="op">=</span> bmesh.new()</div>
<div class="sourceLine" id="cb1-5" data-line-number="5">mesh.from_mesh(<span class="bu">object</span>.data)</div>
<div class="sourceLine" id="cb1-6" data-line-number="6"></div>
<div class="sourceLine" id="cb1-7" data-line-number="7"><span class="co"># Split quads etc. into triangles</span></div>
<div class="sourceLine" id="cb1-8" data-line-number="8">bmesh.ops.triangulate(mesh, faces<span class="op">=</span>mesh.faces[:])</div>
<div class="sourceLine" id="cb1-9" data-line-number="9"></div>
<div class="sourceLine" id="cb1-10" data-line-number="10"><span class="co"># Iterate over faces and vertices.</span></div>
<div class="sourceLine" id="cb1-11" data-line-number="11"><span class="cf">for</span> face <span class="kw">in</span> mesh.faces:</div>
<div class="sourceLine" id="cb1-12" data-line-number="12">    material_index <span class="op">=</span> face.material_index</div>
<div class="sourceLine" id="cb1-13" data-line-number="13">    normal <span class="op">=</span> face.normal <span class="co"># for flat shading</span></div>
<div class="sourceLine" id="cb1-14" data-line-number="14"></div>
<div class="sourceLine" id="cb1-15" data-line-number="15">    <span class="cf">for</span> vert <span class="kw">in</span> face.verts:</div>
<div class="sourceLine" id="cb1-16" data-line-number="16">        position <span class="op">=</span> vert.co</div>
<div class="sourceLine" id="cb1-17" data-line-number="17">        normal <span class="op">=</span> vert.normal <span class="co"># for smooth shading</span></div>
<div class="sourceLine" id="cb1-18" data-line-number="18"></div>
<div class="sourceLine" id="cb1-19" data-line-number="19">mesh.free()</div></code></pre>
<p>You probably also want to export materials, which can be retrieved as follows:</p>
<pre class="sourceCode python" id="cb2"><code class="sourceCode python"><div class="sourceLine" id="cb2-1" data-line-number="1"><span class="cf">for</span> material_slot <span class="kw">in</span> <span class="bu">object</span>.material_slots:</div>
<div class="sourceLine" id="cb2-2" data-line-number="2">    material <span class="op">=</span> material_slot.material</div>
<div class="sourceLine" id="cb2-3" data-line-number="3">    <span class="cf">if</span> material <span class="kw">is</span> <span class="va">None</span>:</div>
<div class="sourceLine" id="cb2-4" data-line-number="4">        <span class="co"># You probably want to cancel the export here</span></div>
<div class="sourceLine" id="cb2-5" data-line-number="5">    <span class="cf">else</span>:</div>
<div class="sourceLine" id="cb2-6" data-line-number="6">        diffuse <span class="op">=</span> material.diffuse_color</div></code></pre>
<p>For the hitboxes themselves, I don’t actually use blenders meshes. The hitboxes are the simple cubes, which I move around in blenders <em>object</em> mode. All info I need about the hitboxes can be retrieved through <code>object.location</code>, <code>object.rotation_*</code> and <code>object.dimensions</code>. Blender stores rotation in different variables depending on the rotation mode selected in the editor. By default, it uses <code>object.rotation_euler</code>. You can call <code>.to_quaternion()</code> on this if you want to export quaternions. Note that these values only are “reliable” if you don’t modify the mesh of an object!</p>
<h2 id="writing-a-binary-file-in-python">Writing a binary file in python</h2>
<p>The last step is actually exporting the data. I chose a binary format, as it seemed simpler both to write and parse. Note that I won’t be covering the parsing of the format here, as that is somewhat language dependent.</p>
<p>In python, you can write binary data to a file using <code>struct.pack</code> (remember to <code>import struct</code> first). For example, <code>struct.pack('&lt;H', my_variable)</code> creates a binary string of an unsigned 16 bit integer in little endian. Further documentation can be found <a href="https://docs.python.org/3/library/struct.html">here</a>.</p>
<p>You can open a file for writing with <code>open(file_path, 'wb')</code>. <code>'wb'</code> stands for write binary.</p>
<p>A simple example:</p>
<pre class="sourceCode python" id="cb3"><code class="sourceCode python"><div class="sourceLine" id="cb3-1" data-line-number="1">filepath <span class="op">=</span> <span class="st">&quot;&quot;</span></div>
<div class="sourceLine" id="cb3-2" data-line-number="2"><span class="cf">with</span> <span class="bu">open</span>(filepath, <span class="st">&#39;wb&#39;</span>) <span class="im">as</span> <span class="bu">file</span>:</div>
<div class="sourceLine" id="cb3-3" data-line-number="3">    my_vector <span class="op">=</span> ...</div>
<div class="sourceLine" id="cb3-4" data-line-number="4">    <span class="bu">file</span>.write(<span class="st">&quot;&lt;fff&quot;</span>, my_vector.x, my_vector.y, my_vector.z)</div></code></pre>
<p>In my exporter, I write a long sequence of vectors to represent a mesh. When importing, I then need to know how long this sequence is so I can read it back from the file. Because of this, I write out the number of elements in a sequence before I write the sequence itself. The same goes for writing strings.</p>
<p>Regarding strings, you also have to encode them into a binary string before writing them. This goes as follows:</p>
<pre class="sourceCode python" id="cb4"><code class="sourceCode python"><div class="sourceLine" id="cb4-1" data-line-number="1">text <span class="op">=</span> <span class="bu">object</span>.name</div>
<div class="sourceLine" id="cb4-2" data-line-number="2">encoded_text <span class="op">=</span> text.encode(<span class="st">&#39;utf-8&#39;</span>)</div>
<div class="sourceLine" id="cb4-3" data-line-number="3"></div>
<div class="sourceLine" id="cb4-4" data-line-number="4"><span class="bu">file</span>.write(struct.pack(<span class="st">&quot;&lt;H&quot;</span>, <span class="bu">len</span>(encoded_text)))</div>
<div class="sourceLine" id="cb4-5" data-line-number="5"><span class="bu">file</span>.write(encoded_text)</div></code></pre>
<p>When parsing, you first read the length and then load the next n bytes as a utf-8 encoded string.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Writing this exporter has allowed me to better integrate blender in my game making process. Furthermore, it brings me a certain joy having finally found what I think is a relatively clean solution to the problem of model importing and exporting. The files created by my exporter are about the same size as standard obj files, but I could probably make them a lot smaller if I were to put in the effort.</p>
<footer>
    <p>Comments and questions are happily accepted at 
    <span class="email_a">morten</span><span class="email_a">hauke</span><span class="email_b">solvang</span><span class="email_a">gmail</span>com

    <p>This site is built using <a href="https://pandoc.org/">pandoc</a>
</footer>
</body>
</html>
